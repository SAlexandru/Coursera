
public class Percolation {
	private final int N_;
	private final byte[] board_;
	private final byte[] firstRow_;
	private final byte[] lastRow_;
	private final WeightedQuickUnionUF union_;
	
	private boolean isPercolating_;
	
	private static int[] dx = new int[] {-1, 0, 0, 1};
	private static int[] dy = new int[] {0, -1, 1, 0};
	
	public Percolation (int N) {
		if (N <= 0) {
			throw new IllegalArgumentException();
		}
		
		N_ = N;
		isPercolating_ = false;
		board_ = new byte[N * N];
		firstRow_ = new byte[N * N];
		lastRow_  = new byte[N * N];
		union_ = new WeightedQuickUnionUF(N_ * N_);
	}
	
	public void open (int i, int j) {
		check(i, j);
		
		final int idx = getIdx (i, j);
		
		if (0 == i) {
			set (firstRow_, idx);
		}
		
		if (N_ == i) {
			set (lastRow_, idx);
		}
		
		for (int k = 0; k < dx.length; ++k) {
			int newI = i + dx[k];
			int newJ = j + dy[k];
			
			if (newI <= 0 || newJ <= 0 || newI > N_ || newJ > N_) {
				continue;
			}
			
			int newIdx = getIdx (newI, newJ);
			
			if (isSet (board_, newIdx)) {
				union_.union(idx, newIdx);
				
				copy (firstRow_, idx, newIdx);
				copy (lastRow_, idx, newIdx);
				copy (firstRow_, idx, union_.find(idx));
				copy (lastRow_, idx, union_.find(newIdx));
			}
		}
		
		for (int k = 0; k < dx.length; ++k) {
			int newI = i + dx[k];
			int newJ = j + dy[k];
			
			if (newI <= 0 || newJ <= 0 || newI > N_ || newJ > N_) {
				continue;
			}
			
			int newIdx = getIdx (newI, newJ);
			
			if (isSet (board_, newIdx)) {
				int root = union_.find(idx);
				
				copy (firstRow_, idx, newIdx);
				copy (lastRow_, idx, newIdx);
				copy (firstRow_, idx, union_.find(idx));
				copy (lastRow_, idx, union_.find(newIdx));
				
				isPercolating_ = isPercolating || 
						(isSet(firstRow_, newIdx) 
			}
		}
		
		
	}
	
	public boolean isOpen(int i, int j) {
		check(i, j);
		return isSet(board_, getIdx(i, j));
	}
	
	public boolean isFull(int i, int j) {
		check(i, j);
		return false;
	}
	
	public boolean percolates() {
		return isPercolating_;
	}
	
	private void check (int i, int j) {
		if (i <= 0 || j <= 0 || i > N_ || j > N_) {
			throw new IndexOutOfBoundsException();
		}
	}
	
	private int getIdx (int i, int j) {return (i - 1) * N_ + j - 1;}
	
	private static void set (final byte[] v, int idx) {v[idx >> 3] |= 1 << (idx & 7);}
	private static boolean isSet(final byte[] v, int idx) {return 0 != (v[idx >> 3] & (1 << (idx & 7)));}
	private static byte get (final byte[] v, int idx) {return isSet(v, idx) ? (byte)1 : (byte)0;}

	private static void copy (final byte[] v, int toIdx, int fromIdx) {
		v[toIdx >> 3] |= get(v, fromIdx) << (toIdx & 7);
		v[fromIdx >> 3] |= get(v, toIdx) << (fromIdx & 7);
	}
}